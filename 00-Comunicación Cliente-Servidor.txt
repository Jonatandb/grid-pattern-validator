FICHAS = [
  {
    id: '1',   desc: 'roja',
  },
  {
    id: '100', desc: 'roja a punto de desaparecer'
  },
  {
    id: '2',   desc: 'verde',
  },
  {
    id: '200', desc: 'verde a punto de desaparecer'
  },
  {
    id: '3',   desc: 'amarilla',
  },
  {
    id: '300', desc: 'amarilla a punto de desaparecer'
  },
  {
    id: '4',   desc: 'azul',
  },
  {
    id: '400', desc: 'azul a punto de desaparecer'
  },
  {
    id: '5',   desc: 'cyan',
  },
  {
    id: '500', desc: 'cyan a punto de desaparecer'
  },
  {
    id: '70',  desc: 'rayo horizontal',
  },
  {
    id: '700', desc: 'rayo horizontal a punto de desaparecer'
  },
  ...
]



                              // CLIENTE        Acción: 1
{
  action: 'start'
}

                              // SERVIDOR       Respuesta: 1
{
  snapshot: {                          3 filas, 5 columnas
    grids: [       ↓
      [ [1  , 2  , 1  , 3  , 3  ],
        [5  , 3  , 3  , 2  , 1  ],   ← Match posible (hay varios):   ↑  (Subir el 3 en [1:2] a [0:2])
        [1  , 3  , 4  , 1  , 4  ] ],
    ],
    matches: [],
    points: 0,
    score:  0
  }
}



                              // CLIENTE        Acción: 2
{
  action: '1:2↑0:2'
}

                              // SERVIDOR       Respuesta: 2
{
  snapshot: {
    grids: [
      [ [1  , 2  , 300, 300, 300],      Simple 1
        [5  , 3  , 1  , 2  , 1  ],
        [1  , 3  , 4  , 1  , 4  ] ],

      [ [1  , 200, 200, 200, 4  ],      Cascada 1
        [5  , 3  , 1  , 2  , 1  ],
        [1  , 3  , 4  , 1  , 4  ] ],

      [ [1  , 300, 400, 400, 400],      Cascadas 2 y 3
        [5  , 300, 1  , 2  , 1  ],
        [1  , 300, 4  , 1  , 4  ] ],
                        ↓
      [ [1  , 2  , 1  , 5  , 1  ],
        [5  , 3  , 1  , 2  , 1  ],
        [1  , 1  , 4  , 1  , 4  ] ], ← Match posible (hay varios):   →  (Mover el 1 en [2:3] a [2:4], a la derecha)
    ],
    matches: ['simple', 'cascade', 'cascade', 'cascade']  // 3 cascades podrían mostrar un "Wow!"
                  Otras opciones de representación:
                    matches: ['S', 'C', 'C', 'C']         // Donde:  'S' simple, 'C' cascade.
                    matches: [1, 2, 2, 2]                 // Donde:   1  simple,  2  cascade.
                    matches: { simple: 1, cascade: 3 }
                    matches: [ { simple: 100 }, { cascade: 3000 }]
    points: 3100,   <= 100 x 1 (simple) + 1000 x 3 (cascades)
    score: 3100
  }
}



                              // CLIENTE        Acción: 3
{
  action: '2:3→2:4'
}

                              // SERVIDOR       Respuesta: 3
{
  snapshot: {
    grids: [
      [ [1  , 2  , 1  , 5  , 100],
        [5  , 3  , 1  , 2  , 100],
        [1  , 1  , 4  , 4  , 100] ],
                                        Matches posibles:
      [ [1  , 2  , 1  , 5  , 2  ],
        [5  , 3  , 1  , 2  , 4  ],      1[1:2]↓[2:2], 2[1:3]→[1:4], 4[1:4]←[1:3], 4[1:4]↓[2:4]
        [1  , 1  , 4  , 4  , 2  ] ],    1[2:1]→[2:2], 4[2:2]←[2:1], 4[2:2]↑[1:2], 2[2:4]↑[1:4]
    ],
    matches: ['simple'],
    points: 100,   <=   100 x1 (simple)
    score: 3200
  }
}



                              // CLIENTE        Acción: 4
{
  action: '0:0→0:1'                     Movimiento sin sentido, se debe "invalidar", el front debe decir "no".
}

                              // SERVIDOR       Respuesta: 4
{
  snapshot: {
    grids: [
      [ [1  , 2  , 1  , 5  , 2  ],      (Está igual)
        [5  , 3  , 1  , 2  , 4  ],
        [1  , 1  , 4  , 4  , 2  ] ],
    ],
    matches: [],                        (Vacío puede representar último movimiento invalidado)
                                        (el tema sería ver como diferenciar esta respuesta de un simple 'get status')
                  Otras opciones de representación:
                    matches: ['invalid']
    points: 0,
    score: 3200
  }
}